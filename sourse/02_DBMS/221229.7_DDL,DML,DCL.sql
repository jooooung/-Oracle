-- [ VII ] DDL, DCL, DML
-- SQL = DDL(테이블 생성, 테이블 삭제, 테이블 구조 변경, 테이블의 모든 테이터 제거)  + 
--       DML(SELECT, INSERT, UPDATE, DELETE) + 
--       DCL(사용자계정 생성, 사용자 권한 부여, 권한박탈, 사용자계정 삭제, 트랜잭션 명령어)

-- ★ DDL ★
-- 1. 테이블 생성(CREATE TABLE 테이블명) : 테이블 구조를 정의하기
CREATE TABLE BOOK (
    BOOKID NUMBER(4),  -- BOOKID 필드의 타입은 숫자 4자리
    BOOKNAME VARCHAR2(50),   -- BOOKNAME필드의 타입은 문자 50BYTE
    PUBLISHER VARCHAR2(50), -- PUBLISHER 필드의 타입은 문자 50BYTE
    RDATE DATE,             -- RDATE 필드의 타입은 DAET
    PRICE NUMBER(8, 2),      -- PRICE필드의 타입은 숫자(전체 8, 소수점 2, 소수점 앞 6)
    PRIMARY KEY(BOOKID)     -- BOOKID필드가 주키(PRIMARY KEY : NOT NULL, UNIQUE)
);
DESC BOOK:

DROP TABLE BOOK;    -- TABLE 삭제

CREATE TABLE BOOK(
    BID NUMBER(4) PRIMARY KEY,
    BNAME VARCHAR2(20),
    PUBLISHER VARCHAR2(20),
    RDATE DATE,
    PRICE NUMBER(9)
    );
SELECT * FROM BOOK;
DESC BOOK;

    -- ex. EMP 테이블과 유사한 EMP01 만들기
--        EMP01 : EMPNO(숫자4), ENAME(문자10), SAL(숫자 2)
CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    SAL NUMBER(9));

    -- ex. DEPT01 테이블 : DEPTNO(숫자 2:PK), ENAME(문자14), LOC(문자13)
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13));
SELECT * FROM EMP01;

    -- EMP02 서브쿼리를 이용한 테이블 생성 
CREATE TABLE EMP02
    AS 
    SELECT * FROM EMP;   -- 서브쿼리 결과로 EMP02 생성 후 데이터도 들어감(제약조건 미포함)
    -- EMP03 : EMP 테이블에서 EMPNO, ENAME, DEPTNO만 추출한 데이터
CREATE TABLE EMP03 AS SELECT EMPNO, ENAME, DEPTNO FROM EMP;
SELECT * FROM EMP03;
    -- EMP04 : EMP 테이블에서 10번 부서만 추출
CREATE TABLE EMP04 AS SELECT * FROM EMP WHERE DEPTNO = 10;
    -- EMP05 : EMP테이블 구조만 추출(데이터 추출 X)
CREATE TABLE EMP05 AS SELECT * FROM EMP WHERE 0=1;   -- WHERE 절에 반드시 거짓인 조건 걸기
SELECT ROWNUM, EMPNO, ENAME, JOB FROM EMP;  -- 테이블에서 행의 논리적 순서(읽어드린 순서)

-- 2. 테이블 구조 변경(ALTER TABLE 테이블명 ADD, MODIFY, DROP ~)
-- (1) 필드 추가(ADD)
SELECT * FROM EMP03;  --EMPNO(수4), ENAME(문10), DEPTNO(수2)
ALTER TABLE EMP03 ADD (JOB VARCHAR2(20), SAL NUMBER(7, 2) );    -- 필드 추가 시 데이터는 NULL
ALTER TABLE EMP03 ADD (COMM NUMBER(7, 2) );

-- (2) 필드 수정(MODIFY)
SELECT * FROM EMP03;  --EMPNO(수4), ENAME(문10), DEPTNO(수2), JOB, SAL, COMM은 NULL
ALTER TABLE EMP03 MODIFY (EMPNO VARCHAR2(5));   -- 숫자데이터가 들어있어 문자로 변경 불가
ALTER TABLE EMP03 MODIFY (EMPNO NUMBER(5)); -- 숫자 데이터는 늘리기만 가능
ALTER TABLE EMP03 MODIFY (SAL VARCHAR2(10));    -- 데이터가 NULL 이면 변경 가능
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(20));  -- 문자는 늘리기 줄이기(데이터의 최소 자리수) 가능

-- (3) 필드 삭제(DROP)
ALTER TABLE EMP03 DROP COLUMN JOB;  
ALTER TABLE EMP03 DROP COLUMN DEPTNO;  -- 데이터까지 다 삭제된다
-- 논리적으로 특정 필드를 접근 못하도록 (낮)
ALTER TABLE EMP03 SET UNUSED (COMM);    -- COMM을 숨김
-- 논리적으로 접근 불가했던 필드를 물리적으로 삭제(새벽)
ALTER TABLE EMP03 DROP UNUSED COLUMNS;

-- 3. 테이블 삭제(DROP TABLE 테이블 명)
DROP TABLE EMP01;   -- EMP01 테이블 삭제
DROP TABLE DEPT;    -- EMP 테이블에서 DEPT 테이블을 참조하는 경우 삭제 X(EMP 삭제 후 DEPT 삭제 가능)

-- 4. 테이블의 모든 행을 제거(TRUNCATE TABLE 테이블명) 
TRUNCATE TABLE EMP03;

-- 5. 테이블명 변경(RENAME 테이블명 TO 바꿀 테이블명)
RENAME EMP02 TO EMP2;
SELECT * FROM EMP2;

-- 6. 데이터 딕셔너리(접근불가) - 데이터딕셔너리 뷰 (접근용)
-- 종류
    --(1) USER_XXX : 현 계정이 소유하고 있는 객체(테이블, 제약조건, 뷰, 인덱스)
       -- USER_TABLES, USER_CONSTRAINTS, USER_INDEXES, USER_VIEWS
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_VIEWS;
    --(2) ALL_XXX : 현 계정에서 접근 가능한 객체(테이블, 제약조건, 뷰, 인덱스)
       -- ALL_TABLES, ALL_CONSTRAINTS, ALL_INDEXES, ALL_VIEWS
SELECT * FROM ALL_TABLES;
SELECT * FROM ALL_VIEWS;
    --(3) DBA_XXX ; DBA권한에서만 접근가능. DBMS의 모든 객체
       -- DBA_TABLES, DBA_CONSTRAINTS, DBA_INDEXES, DBA_VIEWS
SELECT * FROM DBA_TABLES;
        
-- ★ ★ ★ DML ★ ★ ★
-- 1. INSERT INTO 테이블명 VALUES (값1, 값2, ...);
   -- INSERT INTO 테이블명 (필드명1, 필드명2,..) VALUES (값1, 값2, ..);
SELECT * FROM DEPT01;
ROLLBACK;
INSERT INTO DEPT01 VALUES (50, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT01 VALUES (60, 'SALES', NULL); -- 명시적으로 NULL추가
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (70, 'RESEARCH', '서대문');
INSERT INTO DEPT01 (LOC, DEPTNO, DNAME) VALUES ('마포', 80, 'IT');
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (90, 'OPERATION'); -- 묵시적으로 NULL 추가
SELECT * FROM DEPT01;
-- 서브쿼리를 이용한 INSERT
    -- ex. dept테이블에서 10~30번 부서를 dept01테이블로 
INSERT INTO DEPT01 SELECT * FROM DEPT WHERE DEPTNO < 40;
SELECT * FROM DEPT01;
    -- ex BOOK (BID = 11, BNAME = '스포츠의학', 출판사는 '한솔출판', 출판일 오늘, 가격 90000)
DESC BOOK;      -- BOOK 테이블의 필드 타입 확인
INSERT INTO BOOK VALUES (11, '스포츠의학', '한솔출판', SYSDATE, 90000);

-- 트랜젝션 명령어 (DML 명령어에서만 적용)
    -- 트랜젝션은 데이터 처리의 한 단위. DML 명령어들이 실행됨과 동시에 트랜잭션 진행
COMMIT; -- 현 트랜잭션의 작업을 DB에 반영
INSERT INTO BOOK VALUES (12, '스포츠의학', '한솔출판', SYSDATE, 90000);
SELECT * FROM BOOK;     -- 결과의 하나는 DB 하나는 트랜잭션에 있는 상태 - 밑에서 롤백하여 DB데이터만 남음
ROLLBACK;   -- 현 트랜잭션의 작업을 취소

-- 연습문제
--다음과 같은 구조로 SAM01테이블을 생성하시오. 같은 이름의 테이블이 존재할 경우 DROP TABLE로
--삭제 후 생성하시오
--? SAM01의 구조 (EMPNO를 주키로)
--? EMPNO(사번) ? NUMBER(4)
--? ENAME(이름) ? VARCHAR2(10)
--? JOB(직책) ? VARCHAR2(9)
--? SAL(급여) ? NUMBER(7,2)
--? EMP 에 저장된 사원 중 10번 부서 소속 사원의 정보를 추가한다
--EMPNO ENAME JOB SAL
--1000 APPLE POLICE 10000
--1010 BANANA NURSE 15000
--1020 ORANGE DOCTOR 25000
--1030 VERY (NULL) 25000
--1040 CAT (NULL) 2000
--7782 CLARK MANAGER 2450
--7839 KING PRESIDENT 5000
--7934 MILLER CLERK 1300
DROP TABLE SAM01;
CREATE TABLE SAM01(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB   VARCHAR2(9),
    SAL   NUMBER(7,2)
);
SELECT * FROM SAM01;
INSERT INTO SAM01 (EMPNO, ENAME, JOB, SAL) 
    VALUES (1000,'APPLE','POLICE',10000);
INSERT INTO SAM01 VALUES (1010,'BANANA','NURSE',15000);
INSERT INTO SAM01 VALUES (1020,'ORANGE','DOCTOR',25000);
INSERT INTO SAM01 (EMPNO, ENAME, SAL) VALUES (1030,'VERY',25000);
INSERT INTO SAM01 VALUES (1040,'CAT',NULL, 2000);
INSERT INTO SAM01 
    SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO=10;
SELECT * FROM SAM01;
COMMIT;

-- 2. UPDATE 테이블명 SET 필드명1=값1(필드명N=값N) (WHERE조건);
    -- UPDATE에 들어오는 서브쿼리는 반드시 단일 행 단일 열
CREATE TABLE EMP01 AS SELECT * FROM EMP;
SELECT * FROM EMP01;
COMMIT;
    -- ex. 부서번호를 30으로 수정
UPDATE EMP01 SET DEPTNO = 30;   -- WHERE절을 쓰지 않으면 DEPTNO 전체 변경   
ROLLBACK;
    -- ex. EMP01 모든 직원의 SAL을 10%씩 인상
UPDATE EMP01 SET SAL = SAL*1.1;
    -- ex. EMP01 10번 부서 직원의 입사일을 오늘로, 부서번호는 30번으로 수정
UPDATE EMP01 SET HIREDATE = SYSDATE, DEPTNO=30 
    WHERE DEPTNO = 10;
SELECT * FROM EMP01;
    -- ex. SAL이 3000이상인 사원만 급여를 10% 인상
UPDATE EMP01 SET SAL = SAL*1.1 WHERE SAL >= 3000;
    -- ex. DALLAS에 근무하는 직원의 급여를 1000$ 인상
UPDATE EMP01 SET SAL = SAL+1000 
    WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');
    -- ex. EMP01 - SCOTT의 부서번호를 20, JOB 은 MANAGER, SAL과 COMM은 500$ 인상, 상사는 KING으로 수정
UPDATE EMP01 
    SET DEPTNO=20, JOB='MANAGER', SAL=SAL+500, COMM=NVL(COMM,0)+500,
        MGR = (SELECT EMPNO FROM EMP WHERE ENAME='KING')
    WHERE ENAME='SCOTT';
    -- ex. DEPT01 의 60번 LOC을 20번 부서의 LOC으로 수정
UPDATE DEPT01 SET LOC=(SELECT LOC FROM DEPT01 WHERE DEPTNO=20)
    WHERE DEPTNO=60;
SELECT * FROM DEPT01;
    -- ex.EMP01에서 모든 사원의 급여와 입사일을 KING의 급여와 입사일로 수정
UPDATE EMP01 SET SAL=(SELECT SAL FROM EMP01 WHERE ENAME='KING'), 
            HIREDATE=(SELECT HIREDATE FROM EMP01 WHERE ENAME='KING');
    
-- 3. DELETE FROM 테이블명 (WHERE 조건);       ROLLBACK 가능
DELETE FROM EMP01;
ROLLBACK;
    -- ex. EMP01 에서 30번 부서 직원만 삭제
DELETE FROM EMP01 WHERE DEPTNO=30;
    -- ex. EMP01 에서 'FORD' 사원 퇴사
DELETE FROM EMP01 WHERE ENAME='FORD';
    -- ex. SAM01테이블에서 JOB이 정해지지 않은 사원 삭체
DELETE FROM SAM01 WHERE JOB IS NULL;
    -- ex. EMP01 에서 부서명이 SALES인 사원을 삭제(서브쿼리 이용)
DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME='SALES');
    -- ex. EMP01에서 부서명이 RESEARCH인 사원 삭제
DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME='RESEARCH');
COMMIT;

-- ★ 연습문제(PDF 2~3) ★
--1. 아럐의 구조를 만족하는 MY_DATA 테이블을 생성하시오. 단 ID가 PRIMARY KEY이다.
--ID - number(4) NAME - varchar2(10) USERID - varchar2(30) SALARY - number(10,2)
--1              Scott                sscott              10,000.00
--2              Ford                 fford               13,000.00
--3              Patel                ppatel              33,000.00
--4              Report               rreport             23,500.00
--5              Good                 ggood               44,450.00
--2. 생성된 테이블에 위의 도표와 같은 값을 입력하는 SQL문을 작성하시오.
--3. TO_CHAR 내장 함수를 이용하여 입력한 자료를 위의 도표와 같은 형식으로 출력하는
--SQL문을 작성하시오.
--4. 자료를 영구적으로 데이터베이스에 등록하는 명령어를 작성하시오.
--5. ID가 3번인 사람의 급여를 65000.00으로 갱신하고 영구적으로 데이터베이스에 반영하라.
--6. NAME이 Ford인 사람을 삭제하고 영구적으로 데이터베이스에 반영하라.
--7. SALARY가 15,000.00 이하인 사람의 급여를 15,000.00으로 변경하라
--8. 위에서 생성한 테이블을 삭제하라.

-- 1.
CREATE TABLE MY_DATA (
    ID NUMBER(4) PRIMARY KEY,
    NAME VARCHAR2(10),
    USERID VARCHAR2(30),
    SALARY NUMBER(10,2) );
-- 2.
INSERT INTO MY_DATA VALUES (1, 'Scott', 'sscott', 10000);
INSERT INTO MY_DATA VALUES (2, 'Ford', 'fford', 13000);
INSERT INTO MY_DATA VALUES (3, 'Patel', 'ppatel', 33000);
INSERT INTO MY_DATA VALUES (4, 'Report', 'rreport', 23500);
INSERT INTO MY_DATA VALUES (5, 'Good', 'ggood', 44450);
SELECT * FROM MY_DATA;
-- 3.
SELECT ID, NAME,USERID, TO_CHAR(SALARY, '99,999.99') SALARY FROM MY_DATA;
-- 4.
COMMIT;
-- 5.
UPDATE MY_DATA SET SALARY = 65000 WHERE ID = 3;
COMMIT;
-- 6.
DELETE FROM MY_DATA WHERE NAME='Ford';
COMMIT;
-- 7.
UPDATE MY_DATA SET SALARY=15000 
    WHERE SALARY IN (SELECT SALARY FROM MY_DATA WHERE SALARY <=15000);
-- 8.
DROP TABLE MY_DATA;

-- 1. EMP 테이블과 같은 구조와 같은 내용의 테이블 EMP01을 생성
--    (테이블이 있을시 제거한 후)하고, 모든 사원의 부서번호를 30번으로 수정합니다.
DROP TABLE EMP01;
CREATE TABLE EMP01 AS SELECT * FROM EMP;
UPDATE EMP01 SET DEPTNO=30;
-- 3. EMP01테이블의 모든 사원의 급여를 10% 인상시키는 UPDATE문을 작성
UPDATE EMP01 SET SAL=SAL*1.1;
-- 4. 급여가 3000이상인 사원만 급여를 10%인상
UPDATE EMP01 SET SAL=SAL*1.1 
    WHERE SAL IN (SELECT SAL FROM EMP01 WHERE SAL >= 3000);
-- 5. EMP01테이블에서 ‘DALLAS’에서 근무하는 직원들의 월급을 1000인상 
UPDATE EMP01 SET SAL = SAL+1000
     WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS');
-- 6. SCOTT사원의 부서번호는 20번으로, 직급은 MANAGER로 한꺼번에 수정
UPDATE EMP01 SET DEPTNO=20, JOB='MANAGER' WHERE ENAME='SCOTT';
-- 7. 부서명이 SALES인 사원을 모두 삭제하는 SQL작성
DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME='SALES');
-- 8. 사원명이 ‘FORD’인 사원을 삭제하는 SQL 작성
DELETE FROM EMP01 WHERE ENAME = 'FORD';
-- 9. SAM01 테이블에서 JOB이 NULL인 사원을 삭제하시오
DELETE FROM SAM01 WHERE JOB IS NULL;
-- 10 .SAM01테이블에서 ENAME이 ORANGE인 사원을 삭제하시오
DELETE FROM SAM01 WHERE ENAME = 'ORANGE';

-- ★ 제약조건 ★ 
-- (1) PRIMARY KEY : 테이블의 각 행을 유일한 값으로 식별하기 위한 필드
-- (2) FOREIGN KEY : 테이블의 열이 다른 테이블의 열을 참조
-- (3) NOT NULL : NULL을 포함하지 않는다
-- (4) UNIQUE : 모든 행의 값이 유일해야 한다. NULL은 중복 허용
-- (5) CHECK(조건) : 해당 조건이 만족(NULL값 허용)
-- (6) DEFAULT : 기본값 설정(해당 열에 데이터 미입력식 NULL이 아닌 DEFAULT값)

    -- DEPT1 & EMP1 테이블 생성
-- 테이블이 있으면 제거(자식테이블 먼저)
DROP TABLE EMP1;
DROP TABLE DEPT1;
CREATE TABLE DEPT1 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME  VARCHAR2(14) NOT NULL UNIQUE,
    LOC    VARCHAR2(14) NOT NULL
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='DEPT1';
CREATE TABLE DEPT1 (    -- 제약조건 쓰기
    DEPTNO NUMBER(2) CONSTRAINT DEPT_PK PRIMARY KEY,
    DNAME  VARCHAR2(14) CONSTRAINT DEPT_U NOT NULL UNIQUE,
    LOC    VARCHAR2(14) CONSTRAINT DEPT_LOC NOT NULL
);
CREATE TABLE DEPT1 (    -- 제약조건 쓰기 2
    DEPTNO NUMBER(2),
    DNAME  VARCHAR2(14) NOT NULL,
    LOC    VARCHAR2(14) NOT NULL,
    CONSTRAINT DEPTNO_P PRIMARY KEY(DEPTNO),
    CONSTRAINT DNAME_U UNIQUE(DNAME)
);
SELECT * FROM USER_INDEXES WHERE TABLE_NAME ='DEPT1';

CREATE TABLE EMP1(  -- 제약조건을 옆에다
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9) NOT NULL,
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL NUMBER(7,2) CHECK(SAL>0),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) REFERENCES DEPT1(DEPTNO)
);
CREATE TABLE EMP1( -- 제약조건을 밑으로
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9) NOT NULL,
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL NUMBER(7,2),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2),
    PRIMARY KEY(EMPNO),
    CHECK(SAL>0),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO)
);
-- DEPT1 데이터 넣어보기
INSERT INTO DEPT1 SELECT * FROM DEPT;
INSERT INTO DEPT1 (DEPTNO, DNAME, LOC) 
    VALUES ( 50, 'IT', 'SEOUL');
INSERT INTO DEPT1 VALUES (60, 'PLANNING', 'PUSAN');
INSERT INTO DEPT1 (DEPTNO, DNAME) VALUES (70, 'CS'); -- LOC이 NOT NULL이기에 오류
INSERT INTO DEPT1 (DEPTNO, DNAME, LOC) 
    VALUES (70, 'CS', 'GANGNAM');
SELECT * FROM DEPT1;

-- EMP1 데이터 넣기
INSERT INTO EMP1 (EMPNO, ENAME, JOB)
    VALUES (1001, 'HONG', 'MANAGER');
SELECT * FROM EMP1; -- MGR, SAL, COMM, DEPTNO 는 자동으로 NULL, HIREDATE는 =DEFAULT값
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL)
    VALUES (1002, 'HONG', 'MANAGER', 10000);
INSERT INTO EMP1
    VALUES (1003, 'KIM', 'MANAGER', NULL, NULL, NULL, NULL, NULL);
    
    
-- ★ 연습문제(PDF4) ★
DROP TABLE BOOK;
DROP TABLE BOOKCATEGORY CASCADE CONSTRAINTS;
CREATE TABLE BOOKCATEGORY(
    CATEGORYCODE NUMBER(4) PRIMARY KEY,
    CATEGORYNAME VARCHAR2(50) UNIQUE,
    OFFICE_LOC VARCHAR2(50) NOT NULL
);
INSERT INTO BOOKCATEGORY 
    VALUES (100, '철학', '3층 인문실');
INSERT INTO BOOKCATEGORY 
    VALUES (200, '인문', '3층 인문실');
INSERT INTO BOOKCATEGORY 
    VALUES (300, '자연과학', '4층 과학실');
INSERT INTO BOOKCATEGORY 
    VALUES (400, 'IT', '4층 과학실');
SELECT * FROM BOOKCATEGORY;
DROP TABLE BOOKCATEGORY;

CREATE TABLE BOOK(
    CATEGORYCODE NUMBER(4),
    bookNO VARCHAR2(50),
    bookNAME VARCHAR2(50),
    PUBLISHER VARCHAR2(50),
    PUBYEAR NUMBER(4) DEFAULT TO_CHAR(SYSDATE, 'YYYY'),
    FOREIGN KEY(CATEGORYCODE) REFERENCES BOOKCATEGORY(CATEGORYCODE),
    PRIMARY KEY(bookNO)
);
SELECT * FROM BOOK;
INSERT INTO BOOK VALUES (100, '100A01', '철학자의 삶', '이젠출판', 2021);
INSERT INTO BOOK VALUES (400, '400A01', '이것이DB다', '다음출판', 2022);

-- 데이터 삭제시
SELECT * FROM BOOK;
DELETE FROM BOOKCATEGORY WHERE CATEGORYCODE=100;    -- CHILD에서 참조하고 있어서 DELETE 불가
DELETE FROM BOOK WHERE CATEGORYCODE=100;    -- 참조하던 BOOK 에서 지움
DELETE FROM BOOKCATEGORY WHERE CATEGORYCODE=100;    -- 참조가 없어져 DELETE 가능
DELETE FROM BOOKCATEGORY WHERE CATEGORYCODE IN (200, 300);
DELETE FROM BOOK;
SELECT * FROM BOOK;
COMMIT;
DELETE FROM BOOKCATEGORY;   -- 자식테이블에서 참조데이터가 없을 시 데이터 DELETE 가능
DROP TABLE BOOKCATEGORY;    -- 자식테이블이 있어서 지워지지 않음 -> BOOK을 먼저 지우고 지워야됨
DROP TABLE BOOK;
DROP TABLE BOOKCATEGORY;

-- 연습문제 2
DROP TABLE STUDENT;
DROP TABLE MAJOR;

CREATE TABLE MAJOR (
    MAJOR_CODE NUMBER(2) PRIMARY KEY,
    MAJOR_NAME VARCHAR2(50), 
    major_OFFICE_LOC VARCHAR2(200)
);
INSERT INTO MAJOR VALUES (1, '컴퓨터공학', 'A101호');
INSERT INTO MAJOR VALUES (2, '빅데이터', 'A102호');
SELECT * FROM MAJOR;

CREATE TABLE STUDENT(
    student_code NUMBER(4) PRIMARY KEY,
    student_NAME VARCHAR2(20),
    SCORE NUMBER(3),
    MAJOR_CODE NUMBER(2),
    FOREIGN KEY(MAJOR_CODE) REFERENCES MAJOR(MAJOR_CODE),
    CHECK(0<=SCORE AND SCORE<=100)
);
INSERT INTO STUDENT VALUES (101, '홍길동', 99, 1);
INSERT INTO STUDENT VALUES (102, '신길동', 100, 2);
SELECT * FROM STUDENT;

SELECT S.*, M.* 
    FROM STUDENT S, MAJOR M 
    WHERE S.MAJOR_CODE=M.MAJOR_CODE
    ORDER BY S.MAJOR_CODE;
    
-- ★ DCL (사용자계정생성, 사용자권한부여, 권한박탈, 사용자계정삭제) ★
-- 계정생성
CREATE USER scott2 IDENTIFIED BY tiger;
-- 권한부여(세션부여)
GRANT CREATE SESSION TO SCOTT2;
-- 권한부여(TABLE, VIEW)
CREATE ROLE ROLEex;
GRANT CREATE TABLE, CREATE VIEW TO ROLEex;
GRANT ROLEex TO SCOTT2;
-- 권한부여(EMP테이블의 모든 권한)
GRANT ALL ON EMP TO SCOTT2;
-- 권한 부여(DEPT테이블의 SELECT 권한)
GRANT SELECT ON DEPT TO SCOTT2;

-- 권한 박탈(DEPT테이블, EMP테이블 권한)  - 접속 해제 후 박탈 추천
REVOKE ALL ON EMP FROM SCOTT2;
REVOKE SELECT ON DEPT FROM SCOTT2;

-- 사용자 계정 삭제 (반드시 접속 해제 후 삭제)
DROP USER scott2 CASCADE;